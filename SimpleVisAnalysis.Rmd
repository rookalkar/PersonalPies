#Setup
```{r}
devtools::install_github("mjskay/tidybayes")
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies=TRUE)


library(dplyr)
library(ggplot2)
library(tidybayes)
library(rstan)
library(devtools)
library(StanHeaders)
library(readxl)
library(data.table)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```


#SIMPLE VIS
## Import Data
This is data that is imported from the Skau et. al study 

Link to study: https://eagereyes.org/blog/2016/a-reanalysis-of-a-study-about-square-pie-charts-from-2009 

https://kosara.net/papers/2010/Kosara_BELIV_2010.pdf

Link to data: https://github.com/eagereyes/pie-summaries/tree/master/data

Let's break down the data for each chart type. 
```{r}
simplevis <- read_excel("~/Desktop/Research Work/PaperFinal/simplevis.xls")
bar <- subset(simplevis, Type == 'bars')
pie <- subset(simplevis, Type == 'piechart')
donut <- subset(simplevis, Type == 'donut')
```

##PIE CHART
### Flipping Results

Since the question asked "What part of whole is this?", some participants answered for the other segement rather than the segemnt being questioned. We are accounting for this error by assuming the "true value" of the segment being judged as 100 - actual_true_value. This is done to ensure that the same segment is considered by the participant and the study.

```{r}
ggplot(pie, aes(x = `distance from correct answer`, y = `distance from opposite answer`)) + 
  geom_point() + 
  geom_vline(xintercept = 7) + 
  geom_abline(intercept = 0, slope = 1) + 
  geom_point(aes(color = "red"), data = subset(pie, (`distance from correct answer` > 7) & (`distance from opposite answer` < `distance from correct answer`))) +
  ggtitle('Flipping for Pie Chart')+
    theme_minimal()
```

As we can see, most of the participant's answers lie below the distance of 7 from the correct answer. Thus, we assumed that participants whose answers were:
1. closer to the opposite answer than the correct asnwer
2. further than 7 from the correct answer

were infact answering for the opposite segment. We flipped these answers to 100 - particpant's answer.

###Single Cycle Model

####Single Cycle Model Function

Let's first write a general function that will fit a single cycle model to the input data. This function generates a plot of the predicted values from the model.

```{r}
run_single_cycle_model_func <- function(input_data, segments, model_file, base_data, title) {
  #fitting the model
  model_object <- stan(file = model_file, data = input_data, iter = 1000, chains = 1, verbose=TRUE)
  
  #extract the value of 'b' (also referred to as power coefficient in literature) generated by the model
  b_data <- spread_draws(model_object, b)
  
  #find all the unique true values of segments that the participant's were asked to estimate
  unique_correct_ans <- unique(base_data$Value)
  
  #We're then going to create a database that matches each beta value generated by our model with each unique value that the participants had to estimate
  data_extract <- merge(b_data, unique_correct_ans, all=TRUE)
  
  #We run our model for the database of beta and true values that we generated above. In this step, we calculate the 'estimate' (predicted value given a certain true value and beta) that our model is generating.
  
  data_predict <- data_extract%>%
    mutate(
      correct_ans = y/100, 
      riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
      ri_value = riminus_value + 1/segments[1],
      p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
      )
  
  #Let's plot our estimates to see what is happening.
  data_predict %>%
    ggplot(aes(x = y)) +
    stat_lineribbon(aes(y = (p-y)), .width = c(.99, .95, .8, .5)) +
    geom_point(aes(y = (flipped_ans - Value), x = Value ), data = pie) +
    scale_fill_brewer() +
    ggtitle(title)+
    labs(x = "True Proportion", y="Bias") +
    theme_minimal()
}
```


####1-Cycle
First, let's look at what happens in the 1 cycle case. The 1 cycle case is one where there is only one segment of the segment i.e the whole circle. 
```{r}
#create input parameter for the model
pie_data = list(n = length(pie$ID), correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments=1)

run_single_cycle_model_func(pie_data, c(1), 'models/single_cycle_model.stan', pie, '1-cycle Cyclical Power Model')
```
We can see that some of the data is being described by this model, however, it doesn't describe all of the data.

####2-Cycles
The 2 cycles case is where there are two segments of the circle i.e segement 1 is from 0% to 50% and segment 2 is from 50% to 100%. The two semicircles of the circle are the two segments with marks at 0, 50, 100.
```{r}
#create input parameter for the model
pie_data = list(n = length(pie$ID), correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments=2)

run_single_cycle_model_func(pie_data, c(2), 'models/single_cycle_model.stan', pie, '2-cycle Cyclical Power Model')

```
This does a much better job of describing the data. However, it's still not a complete description.


####4-Cycles
The 4 cycles case is where there are four segments of the circle (each quarter of the circle is a segment) with marks at 0, 25, 50, 75, 100.
```{r}
#create input parameter for the model
pie_data = list(n = length(pie$ID), correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments=4)

run_single_cycle_model_func(pie_data, c(4), 'models/single_cycle_model.stan', pie, '4-cycle Cyclical Power Model')

```

###Weighted Cycles Model
From the above single cycle models we saw that some did a decent job at describing some data while some others did a decent job at describing other parts of the data. This hints towards the exisitence of a mixed model. This mixed model is essentially saying that people are using different strategies based on different true values. 
```{r}

pie_data = list(n = length(pie$ID), number_segments = 3, correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments = c(1,2,4))

fit_object_weighted <- stan(file = 'models/weighted_cycles_model.stan', data = pie_data, iter = 1000, chains = 1, verbose=TRUE)

#building the new DB
b_and_p_data <- as.matrix(fit_object_weighted, pars = c("prob_segment", "b" ))
fit_data <- as.data.frame(b_and_p_data)

unique_correct_ans <- as.data.frame(unique(pie$Value))

fit_data <- cbind(fit_data, correct_ans = rep(unique_correct_ans$`unique(pie$Value)`, each = nrow(fit_data_m)))

#extract value of beta (power coefficient) and the probability of each of the three individual single cycles models  being picked (1 cycle: stored in prob_segment1, 2 cycle stored in prob_segment2, 4 cycle stored in prob_segment3)

b = fit_data$b
prob_segment1 = fit_data$`prob_segment[1]`
prob_segment2 = fit_data$`prob_segment[2]`
prob_segment3 = fit_data$`prob_segment[3]`
segment1 = 1
segment2 = 2
segment3 = 4
correct_ans = fit_data$correct_ans/100

# As per the cyclical power model equation, we need to find which segement the true value lies in. For instance, the true value 0.33 lies in the first segement (Ri-1 = 0, Ri = 0.5) in a 2 cycle model and second segment (Ri-1 = 0.25, Ri = 0.5) in the 4 cycles model.

riminus_value1 = floor(correct_ans*segment1)*(1/segment1);
ri_value1 = riminus_value1 + 1/segment1;

#We use these Ri, Ri-1 values to calculate the predicted estimate based on our model for each of the single cycle models

p1 = ((correct_ans - riminus_value1)^b)/((correct_ans - riminus_value1)^b+(ri_value1 - correct_ans)^b)*(1/segment1) + (riminus_value1);

riminus_value2 = floor(correct_ans*segment2)*(1/segment2);
ri_value2 = riminus_value2 + 1/segment2;
p2 = ((correct_ans - riminus_value2)^b)/((correct_ans - riminus_value2)^b+(ri_value2 - correct_ans)^b)*(1/segment2) + (riminus_value2);

riminus_value3 = floor(correct_ans*segment3)*(1/segment3);
ri_value3 = riminus_value3 + 1/segment3;
p3 = ((correct_ans - riminus_value3)^b)/((correct_ans - riminus_value3)^b+(ri_value3 - correct_ans)^b)*(1/segment3) + (riminus_value3);

#Finally, we calculate the overall estimate using the estimates from the three models weighted by the probability of picking that model. 

fit_data$p = (prob_segment1*p1 + prob_segment2*p2 + prob_segment3*p3)*100;

fit_data %>%
ggplot(aes(x = correct_ans)) +
stat_lineribbon(aes(y = (p-correct_ans)), .width = c(.99, .95, .8, .5)) +
# geom_point(aes(y = (flipped_ans - correct_ans), x = correct_ans ), data = flipped_pie_angle) +
stat_smooth(data=pie, aes(x =Value, y =(flipped_ans-Value) ) , color = "green", span = .3) +
stat_summary(fun.data = "mean_se", geom="pointrange", data = pie, aes(x =Value, y =(flipped_ans-Value))) +
scale_fill_brewer() +
ggtitle("Pie Mixture Model (1-cycle,2-cycle,4-cycle)") +
labs(x = "True Proportion", y="Bias") +
theme_minimal()

mean(fit_data$`prob_segment[1]`)
mean(fit_data$`prob_segment[2]`)
mean(fit_data$`prob_segment[3]`)
    
```

```{r}
cuts <- c(0, seq(0.025, max(pie$flipped_ans/100)+0.05, by=0.05), Inf)
pie2 <- transform(pie, class=cut(flipped_ans/100, cuts, right=FALSE))
summary(pie2)
pie2 <- transform(pie2, ycat=as.integer(class))
head(pie2, 25)
```



###Individual Power, Pooled Weights Model
```{r}
pie_data = list(n = length(pie$ID), correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = pie$ID, k = max(pie$ID))

fit3_pie <- stan(file ='models/pooled_wts_indv_power.stan' , data = pie_data, iter = 1000, chains = 1, verbose=TRUE)

fit_data_pie_p <- spread_samples(fit3_pie, b[participant_ID], prob_segment[segment])

unique_correct_ans <- unique(pie$Value)

fit_data_pie_p_f <- merge(fit_data_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, b, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(pie)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .prob = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(pie, participant_ID <= 9 )) +
  ggtitle("Pooled Weights Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

theme_set(theme_minimal())

```

###Pooled Power, Individual Weights Model
```{r}
fit4_pie <- stan(file = 'models/indv_wts_pooled_power_model.stan', data = pie_data, iter = 1000, chains = 1, verbose=TRUE)

fit_data_pie_p <- spread_samples(fit4_pie, b, prob_segment[participant_ID][segment])

unique_correct_ans <- unique(pie$Value)

fit_data_pie_p_f <- merge(fit_data_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, b, participant_ID, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(pie)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (final_p - y)), .prob = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3 ) + 
      geom_point(aes (y = (flipped_ans - Value), x=Value ), data= subset(pie, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weights Pooled Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

```

###Individual Power, Individual Weights Model
```{r}

fit5_pie <- stan(file = 'models/indv_wts_and_power_model.stan', data = pie_data, iter = 1000, chains = 1, verbose=TRUE,control = list(adapt_delta = 0.9))

fit_data_pie_p <- spread_samples(fit5_pie, b[participant_ID], prob_segment[participant_ID][segment])

unique_correct_ans <- unique(pie$Value)

fit_data_pie_p_f <- merge(fit_data_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, y, b) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(pie)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .prob = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(pie, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weight, Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

##BAR CHART
### Flipping Results
```{r}
ggplot(bar, aes(x = `distance from correct answer`, y = `distance from opposite answer`)) + 
  geom_point() + 
  geom_vline(xintercept = 7) + 
  geom_abline(intercept = 0, slope = 1) + 
  geom_point(aes(color = "red"), data = subset(bar, (`distance from correct answer` > 7) & (`distance from opposite answer` < `distance from correct answer`))) +
  ggtitle('Flipping for Bar Chart')+
    theme_minimal()
```

####1-Cycles
```{r}
bar_data = list(n = length(bar$ID), correct_ans = bar$Value/100, response = bar$flipped_ans/100, segments=1)

fit11_bar <- stan(file = 'models/single_cycle_model.stan', data = bar_data, iter = 1000, chains = 1, verbose=TRUE)

model <- stan_model(file = 'models/single_cycle_model.stan') 


fit11_bar_data <- spread_samples(fit11_bar, b)
unique_correct_ans <- unique(bar$Value)
fit11_bar_data <- merge(fit11_bar_data, unique_correct_ans, all=TRUE)

segments <- c(1);
#update this with segments used in the model

fit11_bar_data <- fit11_bar_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit11_bar_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .prob = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = bar) +
  scale_fill_brewer() +
  ggtitle("1-cycle Cyclical Power Model for Bar Chart")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

####2-Cycles
```{r}
bar_data = list(n = length(bar$ID), correct_ans = bar$Value/100, response = bar$flipped_ans/100, segments=2)
fit12_bar <- stan(file = 'models/single_cycle_model.stan', data = bar_data, iter = 1000, chains = 1, verbose=TRUE)

fit12_bar_data <- spread_samples(fit12_bar, b)
unique_correct_ans <- unique(bar$Value)
fit12_bar_data <- merge(fit12_bar_data, unique_correct_ans, all=TRUE)

segments <- c(2);
#update this with segments used in the model

fit12_bar_data <- fit12_bar_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit12_bar_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .prob = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = bar) +
  scale_fill_brewer() +
  ggtitle("2-cycle Cyclical Power Model for Bar Chart")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```



####4-Cycles
```{r}
bar_data = list(n = length(bar$ID), correct_ans = bar$Value/100, response = bar$flipped_ans/100, segments=4)
fit14_bar <- stan(file = 'models/single_cycle_model.stan', data = bar_data, iter = 1000, chains = 1, verbose=TRUE)

fit14_bar_data <- spread_samples(fit14_bar, b)
unique_correct_ans <- unique(bar$Value)
fit14_bar_data <- merge(fit14_bar_data, unique_correct_ans, all=TRUE)

segments <- c(4);
#update this with segments used in the model

fit14_bar_data <- fit14_bar_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit14_bar_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .prob = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = bar) +
  scale_fill_brewer() +
  ggtitle("4-cycle Cyclical Power Model for Bar Chart")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

###Weighted Cycles Model
```{r}

bar_data = list(n = length(bar$ID), number_segments = 3, correct_ans = bar$Value/100, response = bar$flipped_ans/100, segments = c(1,2,4))

fit2_bar <- stan(file = 'models/weighted_cycles_model.stan', data = bar_data, iter = 1000, chains = 1, verbose=TRUE)

#building the new DB
b_and_p <- as.matrix(fit2_bar, pars = c("prob_segment", "b" ))
fit_data_m <- as.data.frame(b_and_p)

unique_correct_ans <- as.data.frame(unique(bar$Value))
fit_data_m <- cbind(fit_data_m, correct_ans = rep(unique_correct_ans$`unique(bar$Value)`, each = nrow(fit_data_m)))

fit_data_m

    b = fit_data_m$b
    prob_segment1 = fit_data_m$`prob_segment[1]`
    prob_segment2 = fit_data_m$`prob_segment[2]`
    prob_segment3 = fit_data_m$`prob_segment[3]`
    segment1 = 1
    segment2 = 2
    segment3 = 4
    correct_ans = fit_data_m$correct_ans/100

    riminus_value1 = floor(correct_ans*segment1)*(1/segment1);
    ri_value1 = riminus_value1 + 1/segment1;
    p1 = ((correct_ans - riminus_value1)^b)/((correct_ans - riminus_value1)^b+(ri_value1 - correct_ans)^b)*(1/segment1) + (riminus_value1);

    riminus_value2 = floor(correct_ans*segment2)*(1/segment2);
    ri_value2 = riminus_value2 + 1/segment2;
    p2 = ((correct_ans - riminus_value2)^b)/((correct_ans - riminus_value2)^b+(ri_value2 - correct_ans)^b)*(1/segment2) + (riminus_value2);

    riminus_value3 = floor(correct_ans*segment3)*(1/segment3);
    ri_value3 = riminus_value3 + 1/segment3;
    p3 = ((correct_ans - riminus_value3)^b)/((correct_ans - riminus_value3)^b+(ri_value3 - correct_ans)^b)*(1/segment3) + (riminus_value3);
    fit_data_m$p = (prob_segment1*p1 + prob_segment2*p2 + prob_segment3*p3)*100;
    
  fit_data_m %>%
  ggplot(aes(x = correct_ans)) +
  stat_lineribbon(aes(y = (p-correct_ans)), .prob = c(.99, .95, .8, .5)) +
 # geom_point(aes(y = (flipped_ans - correct_ans), x = correct_ans ), data = flipped_bar_angle) +
  stat_smooth(data=bar, aes(x =Value, y =(flipped_ans-Value) ) , color = "green", span = .3) +
  stat_summary(fun.data = "mean_se", geom="pointrange", data = bar, aes(x =Value, y =(flipped_ans-Value))) +
  scale_fill_brewer() +
  ggtitle("Bar Chart Mixture Model (1-cycle,2-cycle,4-cycle)") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
    
    mean(fit_data_m$`prob_segment[1]`)
    mean(fit_data_m$`prob_segment[2]`)
    mean(fit_data_m$`prob_segment[3]`)
    
```

###Individual Power, Pooled Weights Model
```{r}
bar_data = list(n = length(bar$ID), correct_ans = bar$Value/100, response = bar$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = bar$ID, k = max(bar$ID))

fit3_bar <- stan(file ='models/pooled_wts_indv_power.stan' , data = bar_data, iter = 1000, chains = 1, verbose=TRUE)

fit_data_bar_p <- spread_samples(fit3_bar, b[participant_ID], prob_segment[segment])

unique_correct_ans <- unique(bar$Value)

fit_data_bar_p_f <- merge(fit_data_bar_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_bar_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, b, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(bar)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .prob = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(bar, participant_ID <= 9 )) +
  ggtitle("Pooled Weights Individual Power Model for Particpants 1-9 for Bar Chart") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

theme_set(theme_minimal())

```

###Pooled Power, Individual Weights Model
```{r}
fit4_bar <- stan(file = 'models/indv_wts_pooled_power_model.stan', data = bar_data, iter = 1000, chains = 1, verbose=TRUE)

fit_data_bar_p <- spread_samples(fit4_bar, b, prob_segment[participant_ID][segment])

unique_correct_ans <- unique(bar$Value)

fit_data_bar_p_f <- merge(fit_data_bar_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_bar_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, b, participant_ID, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(bar)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (final_p - y)), .prob = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3 ) + 
      geom_point(aes (y = (flipped_ans - Value), x=Value ), data= subset(bar, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weights Pooled Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

```

###Individual Power, Individual Weights Model
```{r}

fit5_bar <- stan(file = 'models/indv_wts_and_power_model.stan', data = bar_data, iter = 1000, chains = 1, verbose=TRUE,control = list(adapt_delta = 0.9))

fit_data_bar_p <- spread_samples(fit5_bar, b[participant_ID], prob_segment[participant_ID][segment])

unique_correct_ans <- unique(bar$Value)

fit_data_bar_p_f <- merge(fit_data_bar_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_bar_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, y, b) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(bar)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .prob = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(bar, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weight, Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

#ARCS AREA ANGLES STUDY
##Import Data 
This is data that is imported from the Kosara et. al study 

Link to study: https://kosara.net/papers/2016/Skau-EuroVis-2016.pdf

Link to data: https://github.com/eagereyes/pie-summaries/blob/master/data/arcs-angles-areas-merged.csv


```{r}

aaa_study <- read_excel("~/Desktop/Research Work/PaperFinal/Arcs Angles Areas Results Data.xlsx" , sheet = "flipped_data")

#Rename column names to match with names from simplevis dataset
setnames(aaa_study, old=c("subjectID","correct_ans"), new=c("ID", "Value"))

aaa_study_pie <- subset(aaa_study, chart_type == 'Pie Chart')
```

##PIE CHART

### Flipping Results
```{r}
ggplot(aaa_study_pie, aes(x = `distance from correct answer`, y = `distance from opposite answer`)) + 
  geom_point() + 
  geom_vline(xintercept = 8) + 
  geom_abline(intercept = 0, slope = 1) + 
  geom_point(aes(color = "red"), data = subset(aaa_study_pie, (`distance from correct answer` > 8) & (`distance from opposite answer` < `distance from correct answer`))) +
  ggtitle('Flipping for Pie Chart')+
    theme_minimal()
```

###Single Cycle Model
####1-Cycle
```{r}
aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments=1)

fit11_aaa_pie <- stan(file = 'models/single_cycle_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

#model <- stan_model(file = 'models/single_cycle_model.stan') 

fit11_aaa_pie_data <- spread_draws(fit11_aaa_pie, b)

unique_correct_ans_aaa <- unique(aaa_study_pie$Value)

fit11_aaa_pie_data <- merge(fit11_aaa_pie_data, unique_correct_ans_aaa, all=TRUE)

segments <- c(1);
#update this with segments used in the model

fit11_aaa_pie_data <- fit11_aaa_pie_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit11_aaa_pie_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .width = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = aaa_study_pie) +
  scale_fill_brewer() +
  ggtitle("1-cycle Cyclical Power Mode")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

####2-Cycles
```{r}
aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments=2)

fit12_aaa_pie <- stan(file = 'models/single_cycle_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

#model <- stan_model(file = 'models/single_cycle_model.stan') 

fit12_aaa_pie_data <- spread_draws(fit12_aaa_pie, b)

unique_correct_ans_aaa <- unique(aaa_study_pie$Value)

fit12_aaa_pie_data <- merge(fit12_aaa_pie_data, unique_correct_ans_aaa, all=TRUE)

segments <- c(2);
#update this with segments used in the model

fit12_aaa_pie_data <- fit12_aaa_pie_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit12_aaa_pie_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .width = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = aaa_study_pie) +
  scale_fill_brewer() +
  ggtitle("2-cycle Cyclical Power Mode")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```


####4-Cycles
```{r}
aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments=4)

fit14_aaa_pie <- stan(file = 'models/single_cycle_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

#model <- stan_model(file = 'models/single_cycle_model.stan') 

fit14_aaa_pie_data <- spread_draws(fit14_aaa_pie, b)

unique_correct_ans_aaa <- unique(aaa_study_pie$Value)

fit14_aaa_pie_data <- merge(fit14_aaa_pie_data, unique_correct_ans_aaa, all=TRUE)

segments <- c(4);
#update this with segments used in the model

fit14_aaa_pie_data <- fit14_aaa_pie_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit14_aaa_pie_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .width = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = aaa_study_pie) +
  scale_fill_brewer() +
  ggtitle("4-cycle Cyclical Power Mode")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

###Weighted Cycles Model
```{r}

aaa_pie_data = list(n = length(aaa_study_pie$ID), number_segments = 3, correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments = c(1,2,4))

fit2_aaa_pie <- stan(file = 'models/weighted_cycles_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

#building the new DB
b_and_p <- as.matrix(fit2_aaa_pie, pars = c("prob_segment", "b" ))
fit_data_m_aaa <- as.data.frame(b_and_p)

unique_correct_ans <- as.data.frame(unique(aaa_study_pie$Value))

fit_data_m_aaa <- cbind(fit_data_m_aaa, correct_ans = rep(unique_correct_ans$`unique(aaa_study_pie$Value)`, each = nrow(fit_data_m_aaa)))

    b = fit_data_m_aaa$b
    prob_segment1 = fit_data_m_aaa$`prob_segment[1]`
    prob_segment2 = fit_data_m_aaa$`prob_segment[2]`
    prob_segment3 = fit_data_m_aaa$`prob_segment[3]`
    segment1 = 1
    segment2 = 2
    segment3 = 4
    correct_ans = fit_data_m_aaa$correct_ans/100

    riminus_value1 = floor(correct_ans*segment1)*(1/segment1);
    ri_value1 = riminus_value1 + 1/segment1;
    p1 = ((correct_ans - riminus_value1)^b)/((correct_ans - riminus_value1)^b+(ri_value1 - correct_ans)^b)*(1/segment1) + (riminus_value1);

    riminus_value2 = floor(correct_ans*segment2)*(1/segment2);
    ri_value2 = riminus_value2 + 1/segment2;
    p2 = ((correct_ans - riminus_value2)^b)/((correct_ans - riminus_value2)^b+(ri_value2 - correct_ans)^b)*(1/segment2) + (riminus_value2);

    riminus_value3 = floor(correct_ans*segment3)*(1/segment3);
    ri_value3 = riminus_value3 + 1/segment3;
    p3 = ((correct_ans - riminus_value3)^b)/((correct_ans - riminus_value3)^b+(ri_value3 - correct_ans)^b)*(1/segment3) + (riminus_value3);
    
    fit_data_m_aaa$p = (prob_segment1*p1 + prob_segment2*p2 + prob_segment3*p3)*100;
    
  fit_data_m_aaa %>%
  ggplot(aes(x = correct_ans)) +
  stat_lineribbon(aes(y = (p-correct_ans)), .width = c(.99, .95, .8, .5)) +
 # geom_point(aes(y = (flipped_ans - correct_ans), x = correct_ans ), data = flipped_pie_angle) +
  stat_smooth(data=pie, aes(x =Value, y =(flipped_ans-Value) ) , color = "green", span = .3) +
  stat_summary(fun.data = "mean_se", geom="pointrange", data = pie, aes(x =Value, y =(flipped_ans-Value))) +
  scale_fill_brewer() +
  ggtitle("Pie Mixture Model (1-cycle,2-cycle,4-cycle)") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
    
    mean(fit_data_m_aaa$`prob_segment[1]`)
    mean(fit_data_m_aaa$`prob_segment[2]`)
    mean(fit_data_m_aaa$`prob_segment[3]`)
    
```

###Individual Power, Pooled Weights Model
```{r}
aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = aaa_study_pie$ID, k = max(aaa_study_pie$ID))

fit3_aaa_pie <- stan(file ='models/pooled_wts_indv_power.stan' , data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

fit_data_aaa_pie_p <- spread_draws(fit3_aaa_pie, b[participant_ID], prob_segment[segment])

unique_correct_ans <- unique(aaa_study_pie$Value)

fit_data_aaa_pie_p_f <- merge(fit_data_aaa_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_aaa_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, b, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(aaa_study_pie)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(aaa_study_pie, participant_ID <= 9 )) +
  ggtitle("Pooled Weights Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

theme_set(theme_minimal())

```


###Pooled Power, Individual Weights Model
```{r}
fit4_aaa_pie <- stan(file = 'models/indv_wts_pooled_power_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

fit_data_aaa_pie_p <- spread_samples(fit4_aaa_pie, b, prob_segment[participant_ID][segment])

unique_correct_ans <- unique(aaa_study_pie$Value)

fit_data_aaa_pie_p_f <- merge(fit_data_aaa_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_aaa_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, b, participant_ID, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
#colnames(pie)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (final_p - y)), .prob = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3 ) + 
      geom_point(aes (y = (flipped_ans - Value), x=Value ), data= subset(aaa_study_pie, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weights Pooled Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

```

###Individual Power, Individual Weights Model
```{r}

fit5_aaa_pie <- stan(file = 'models/indv_wts_and_power_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE,control = list(adapt_delta = 0.9))

fit_data_aaa_pie_p <- spread_samples(fit5_aaa_pie, b[participant_ID], prob_segment[participant_ID][segment])

unique_correct_ans <- unique(aaa_study_pie$Value)

fit_data_aaa_pie_p_f <- merge(fit_data_aaa_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data <- fit_data_aaa_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, y, b) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
#colnames(pie)[1] <- "participant_ID"

final_data %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .prob = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(aaa_study_pie, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weight, Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```