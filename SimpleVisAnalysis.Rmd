#Setup
```{r setup}

library(dplyr)
library(ggplot2)
library(tidybayes)
library(rstan)
library(devtools)
library(StanHeaders)
library(readxl)
library(data.table)
library(sma)
library(tidyr)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```


#SIMPLE VIS
## Import Data
This is data that is imported from the Skau et. al study 

Link to study: https://eagereyes.org/blog/2016/a-reanalysis-of-a-study-about-square-pie-charts-from-2009 

https://kosara.net/papers/2010/Kosara_BELIV_2010.pdf

Link to data: https://github.com/eagereyes/pie-summaries/tree/master/data

Let's break down the data for each chart type. 
```{r import simplevis data}
simplevis <- read_excel("~/Desktop/Research Work/PaperFinal/simplevis.xls")
bar <- subset(simplevis, Type == 'bars')
pie <- subset(simplevis, Type == 'piechart')
donut <- subset(simplevis, Type == 'donut')
```

##PIE CHART
### Flipping Results

Since the question asked "What part of whole is this?", some participants answered for the other segement rather than the segemnt being questioned. We are accounting for this error by assuming the "true value" of the segment being judged as 100 - actual_true_value. This is done to ensure that the same segment is considered by the participant and the study.

```{r flipping for simplevis data}
ggplot(pie, aes(x = `distance from correct answer`, y = `distance from opposite answer`)) + 
  geom_point() + 
  geom_vline(xintercept = 7) + 
  geom_abline(intercept = 0, slope = 1) + 
  geom_point(aes(color = "red"), data = subset(pie, (`distance from correct answer` > 7) & (`distance from opposite answer` < `distance from correct answer`))) +
  ggtitle('Flipping for Pie Chart')+
    theme_minimal()
```

As we can see, most of the participant's answers lie below the distance of 7 from the correct answer. Thus, we assumed that participants whose answers were:
1. closer to the opposite answer than the correct asnwer
2. further than 7 from the correct answer

were infact answering for the opposite segment. We flipped these answers to 100 - particpant's answer.

###Single Cycle Model

####Single Cycle Model Function

Let's first write a general function that will fit a single cycle model to the input data. This function generates a plot of the predicted values from the model.

```{r function to fit single cycle model}
run_single_cycle_model_func <- function(input_data, segments, model_file, base_data, title) {
  #fitting the model
  model_object <- stan(file = model_file, data = input_data, iter = 1000, chains = 1, verbose=TRUE)
  
  #extract the value of 'b' (also referred to as power coefficient in literature) generated by the model
  b_data <- spread_draws(model_object, b)
  
  #find all the unique true values of segments that the participant's were asked to estimate
  unique_correct_ans <- unique(base_data$Value)
  
  #We're then going to create a database that matches each beta value generated by our model with each unique value that the participants had to estimate
  data_extract <- merge(b_data, unique_correct_ans, all=TRUE)
  
  #We run our model for the database of beta and true values that we generated above. In this step, we calculate the 'estimate' (predicted value given a certain true value and beta) that our model is generating.
  
  data_predict <- data_extract%>%
    mutate(
      correct_ans = y/100, 
      riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
      ri_value = riminus_value + 1/segments[1],
      p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
      )
  
  #Let's plot our estimates to see what is happening.
  data_predict %>%
    ggplot(aes(x = y)) +
    stat_lineribbon(aes(y = (p-y)), .width = c(.99, .95, .8, .5)) +
    geom_point(aes(y = (flipped_ans - Value), x = Value ), data = pie) +
    scale_fill_brewer() +
    ggtitle(title)+
    labs(x = "True Proportion", y="Bias") +
    theme_minimal()
}
```


####1-Cycle
First, let's look at what happens in the 1 cycle case. The 1 cycle case is one where there is only one segment of the segment i.e the whole circle. 
```{r simplevis: fit 1 cycle single cycle model}
#create input parameter for the model
pie_data = list(n = length(pie$ID), correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments=1)

run_single_cycle_model_func(pie_data, c(1), 'models/single_cycle_model.stan', pie, '1-cycle Cyclical Power Model')
```
We can see that some of the data is being described by this model, however, it doesn't describe all of the data.

####2-Cycles
The 2 cycles case is where there are two segments of the circle i.e segement 1 is from 0% to 50% and segment 2 is from 50% to 100%. The two semicircles of the circle are the two segments with marks at 0, 50, 100.
```{r simplevis: fit 2 cycle single cycle model}
#create input parameter for the model
pie_data = list(n = length(pie$ID), correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments=2)

run_single_cycle_model_func(pie_data, c(2), 'models/single_cycle_model.stan', pie, '2-cycle Cyclical Power Model')

```
This does a much better job of describing the data. However, it's still not a complete description.


####4-Cycles
The 4 cycles case is where there are four segments of the circle (each quarter of the circle is a segment) with marks at 0, 25, 50, 75, 100.
```{r simplevis: fit 4 cycle single cycle model}
#create input parameter for the model
pie_data = list(n = length(pie$ID), correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments=4)

run_single_cycle_model_func(pie_data, c(4), 'models/single_cycle_model.stan', pie, '4-cycle Cyclical Power Model')

```

###Weighted Cycles Model
From the above single cycle models we saw that some did a decent job at describing some data while some others did a decent job at describing other parts of the data. This hints towards the exisitence of a mixed model. This mixed model is essentially saying that people are using different strategies based on different true values.

```{r simplevis: fit weighted cycles model}

pie_data = list(n = length(pie$ID), number_segments = 3, correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments = c(1,2,4))

fit_object_weighted <- stan(file = 'models/weighted_cycles_model.stan', data = pie_data, iter = 1000, chains = 1, verbose=TRUE)

#building the new DB
b_and_p_data <- as.matrix(fit_object_weighted, pars = c("prob_segment", "b" ))
fit_data <- as.data.frame(b_and_p_data)

unique_correct_ans <- as.data.frame(unique(pie$Value))

fit_data <- cbind(fit_data, correct_ans = rep(unique_correct_ans$`unique(pie$Value)`, each = nrow(fit_data_m)))

#extract value of beta (power coefficient) and the probability of each of the three individual single cycles models  being picked (1 cycle: stored in prob_segment1, 2 cycle stored in prob_segment2, 4 cycle stored in prob_segment3)

b = fit_data$b
prob_segment1 = fit_data$`prob_segment[1]`
prob_segment2 = fit_data$`prob_segment[2]`
prob_segment3 = fit_data$`prob_segment[3]`
segment1 = 1
segment2 = 2
segment3 = 4
correct_ans = fit_data$correct_ans/100

# As per the cyclical power model equation, we need to find which segement the true value lies in. For instance, the true value 0.33 lies in the first segement (Ri-1 = 0, Ri = 0.5) in a 2 cycle model and second segment (Ri-1 = 0.25, Ri = 0.5) in the 4 cycles model.

riminus_value1 = floor(correct_ans*segment1)*(1/segment1);
ri_value1 = riminus_value1 + 1/segment1;

#We use these Ri, Ri-1 values to calculate the predicted estimate based on our model for each of the single cycle models

p1 = ((correct_ans - riminus_value1)^b)/((correct_ans - riminus_value1)^b+(ri_value1 - correct_ans)^b)*(1/segment1) + (riminus_value1);

riminus_value2 = floor(correct_ans*segment2)*(1/segment2);
ri_value2 = riminus_value2 + 1/segment2;
p2 = ((correct_ans - riminus_value2)^b)/((correct_ans - riminus_value2)^b+(ri_value2 - correct_ans)^b)*(1/segment2) + (riminus_value2);

riminus_value3 = floor(correct_ans*segment3)*(1/segment3);
ri_value3 = riminus_value3 + 1/segment3;
p3 = ((correct_ans - riminus_value3)^b)/((correct_ans - riminus_value3)^b+(ri_value3 - correct_ans)^b)*(1/segment3) + (riminus_value3);

#Finally, we calculate the overall estimate using the estimates from the three models weighted by the probability of picking that model. 

fit_data$p = (prob_segment1*p1 + prob_segment2*p2 + prob_segment3*p3)*100;

fit_data %>%
ggplot(aes(x = correct_ans)) +
stat_lineribbon(aes(y = (p-correct_ans)), .width = c(.99, .95, .8, .5)) +
# geom_point(aes(y = (flipped_ans - correct_ans), x = correct_ans ), data = flipped_pie_angle) +
stat_smooth(data=pie, aes(x =Value, y =(flipped_ans-Value) ) , color = "green", span = .3) +
stat_summary(fun.data = "mean_se", geom="pointrange", data = pie, aes(x =Value, y =(flipped_ans-Value))) +
scale_fill_brewer() +
ggtitle("Pie Mixture Model (1-cycle,2-cycle,4-cycle)") +
labs(x = "True Proportion", y="Bias") +
theme_minimal()

mean(fit_data$`prob_segment[1]`)
mean(fit_data$`prob_segment[2]`)
mean(fit_data$`prob_segment[3]`)
    
```

```{r }
cuts <- c(0, seq(0.025, max(pie$flipped_ans/100)+0.05, by=0.05), Inf)
pie2 <- transform(pie, class=cut(flipped_ans/100, cuts, right=FALSE))
summary(pie2)
pie2 <- transform(pie2, ycat=as.integer(class))
head(pie2, 25)
```


```{r simplevis: weighted cycles model QQ plot}
predicted_answers <- fit_data$p
actual_answers <- pie$Estimate

qqplot(actual_answers, predicted_answers)
q <- quantile(actual_answers)
plot.qqline(q, predicted_answers)
```


###Individual Power, Pooled Weights Model
```{r simplevis: fit IPPW cycles model}
pie_data = list(n = length(pie$ID), correct_ans = pie$Value/100, response = pie$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = pie$ID, k = max(pie$ID))

fit3_pie <- stan(file ='models/pooled_wts_indv_power.stan' , data = pie_data, iter = 1000, chains = 1, verbose=TRUE)

saveRDS(fit3_pie, "fit_pooled_wts_indv_power.rds")

#fit3_pie <- readRDS("fit_pooled_wts_indv_power.rds")

fit3_data_pie_p <- spread_draws(fit3_pie, b[participant_ID], prob_segment[segment])

unique_correct_ans <- unique(pie$Value)

fit3_data_pie_p_f <- merge(fit3_data_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data3 <- fit3_data_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, b, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(pie)[1] <- "participant_ID"

final_data3 %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(pie, participant_ID <= 9 )) +
  ggtitle("Pooled Weights Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

theme_set(theme_minimal())

```


```{r simplevis: IPPW model QQ plots}

for (i in 1:10) {
  predicted_answers <- filter(final_data3, participant_ID == i)$final_p
  actual_answers <- filter(pie, participant_ID == i)$Estimate

  qqplot(actual_answers, predicted_answers)
  q <- quantile(actual_answers)
  plot.qqline(q, predicted_answers)
}

```

```{r simplevis: IPPW model posteroir plots}

predicted_data <- subset(final_data3, participant_ID <= 6 )
observed_data <- subset(pie, participant_ID <= 6 )

ggplot(predicted_data, aes(y, final_p)) + geom_point() + geom_point(data = observed_data, aes(Value, Estimate), colour='red') + facet_wrap( ~ participant_ID, nrow = 3) + ggtitle("Individual Power, Pooled Weights Model for Particpants 1-6") + labs(x = "Correct Answer", y="Response")
```

###Pooled Power, Individual Weights Model
```{r simplevis: fit PPIW model}
fit4_pie <- stan(file = 'models/indv_wts_pooled_power_model.stan', data = pie_data, iter = 1000, chains = 1, verbose=TRUE)

saveRDS(fit4_pie, "fit_indv_wts_pooled_power_model.rds")

#fit4_pie <- readRDS("fit_indv_wts_pooled_power_model.rds")

fit4_data_pie_p <- spread_draws(fit4_pie, b, prob_segment[participant_ID][segment])

unique_correct_ans <- unique(pie$Value)

fit4_data_pie_p_f <- merge(fit4_data_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data4 <- fit4_data_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, b, participant_ID, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(pie)[1] <- "participant_ID"

final_data4 %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (final_p - y)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3 ) + 
      geom_point(aes (y = (flipped_ans - Value), x=Value ), data= subset(pie, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weights Pooled Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

```

```{r simplevis: PPIW model QQ plots}

for (i in 1:10) {
  predicted_answers <- filter(final_data4, participant_ID == i)$final_p
  actual_answers <- filter(pie, participant_ID == i)$Estimate

  qqplot(actual_answers, predicted_answers)
  q <- quantile(actual_answers)
  plot.qqline(q, predicted_answers)
}

```

```{r simplevis: PPIW model posteroir plots}

predicted_data <- subset(final_data4, participant_ID <= 6 )
observed_data <- subset(pie, participant_ID <= 6 )

ggplot(predicted_data, aes(y, final_p)) + geom_point() + geom_point(data = observed_data, aes(Value, Estimate), colour='red') + facet_wrap( ~ participant_ID, nrow = 3) + ggtitle("Pooled Power, Individual Weights Model for Particpants 1-6") + labs(x = "Correct Answer", y="Response")
```

###Individual Power, Individual Weights Model
```{r simplevis: fit IPIW model}

fit5_pie <- stan(file = 'models/indv_wts_and_power_model.stan', data = pie_data, iter = 1000, chains = 1, verbose=TRUE,control = list(adapt_delta = 0.9))

saveRDS(fit5_pie, "fit_indv_wts_and_power_model.rds")

#fit5_pie <- readRDS("fit_indv_wts_and_power_model.rds")

fit5_data_pie_p <- spread_draws(fit5_pie, b[participant_ID], prob_segment[participant_ID][segment])

unique_correct_ans <- unique(pie$Value)

fit5_data_pie_p_f <- merge(fit5_data_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data5 <- fit5_data_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, y, b) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(pie)[1] <- "participant_ID"

final_data5 %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(pie, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weight, Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

```{r simplevis: IPIW model QQ plots}

for (i in 1:10) {
  predicted_answers <- filter(final_data5, participant_ID == i)$final_p
  actual_answers <- filter(pie, participant_ID == i)$Estimate

  qqplot(actual_answers, predicted_answers)
  q <- quantile(actual_answers)
  plot.qqline(q, predicted_answers)
}

```
```{r simplevis: checking QQ plots for IPIW, IPPW, PPIW models}
predicted_answers <- filter(final_data3, participant_ID == 1)$final_p
actual_answers <- filter(pie, participant_ID == 1)$Estimate
qqplot(actual_answers, predicted_answers, ylab = "IPPW Predicted Answers")
q <- quantile(actual_answers)
plot.qqline(q, predicted_answers)

predicted_answers <- filter(final_data4, participant_ID == 1)$final_p
actual_answers <- filter(pie, participant_ID == 1)$Estimate
qqplot(actual_answers, predicted_answers, ylab = "PPIW Predicted Answers")
q <- quantile(actual_answers)
plot.qqline(q, predicted_answers)

predicted_answers <- filter(final_data5, participant_ID == 1)$final_p
actual_answers <- filter(pie, participant_ID == 1)$Estimate
qqplot(actual_answers, predicted_answers, ylab = "IPIW Predicted Answers")
q <- quantile(actual_answers)
plot.qqline(q, predicted_answers)
  
```

```{r simplevis: IPIW model posteroir plots}

predicted_data <- subset(final_data5, participant_ID <= 6 )
observed_data <- subset(pie, participant_ID <= 6 )

ggplot(predicted_data, aes(y, final_p)) + geom_point() + geom_point(data = observed_data, aes(Value, Estimate), colour='red') + facet_wrap( ~ participant_ID, nrow = 3) + ggtitle("Individual Power, Individual Weights Model for Particpants 1-6") + labs(x = "Correct Answer", y="Response")
```



#ARCS AREA ANGLES STUDY
##Import Data 
This is data that is imported from the Kosara et. al study 

Link to study: https://kosara.net/papers/2016/Skau-EuroVis-2016.pdf

Link to data: https://github.com/eagereyes/pie-summaries/blob/master/data/arcs-angles-areas-merged.csv


```{r import AAA data}

aaa_study <- read_excel("~/Desktop/Research Work/PaperFinal/Arcs Angles Areas Results Data.xlsx" , sheet = "flipped_data")

#Rename column names to match with names from simplevis dataset
setnames(aaa_study, old=c("subjectID","correct_ans"), new=c("ID", "Value"))

aaa_study_pie <- subset(aaa_study, chart_type == 'Pie Chart')
```

##PIE CHART

### Flipping Results
```{r flip AAA data}
ggplot(aaa_study_pie, aes(x = `distance from correct answer`, y = `distance from opposite answer`)) + 
  geom_point() + 
  geom_vline(xintercept = 8) + 
  geom_abline(intercept = 0, slope = 1) + 
  geom_point(aes(color = "red"), data = subset(aaa_study_pie, (`distance from correct answer` > 8) & (`distance from opposite answer` < `distance from correct answer`))) +
  ggtitle('Flipping for Pie Chart')+
    theme_minimal()
```

###Single Cycle Model
####1-Cycle
```{r AAA: fit 1-cycle single cycle model}
aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments=1)

fit11_aaa_pie <- stan(file = 'models/single_cycle_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

#model <- stan_model(file = 'models/single_cycle_model.stan') 

fit11_aaa_pie_data <- spread_draws(fit11_aaa_pie, b)

unique_correct_ans_aaa <- unique(aaa_study_pie$Value)

fit11_aaa_pie_data <- merge(fit11_aaa_pie_data, unique_correct_ans_aaa, all=TRUE)

segments <- c(1);
#update this with segments used in the model

fit11_aaa_pie_data <- fit11_aaa_pie_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit11_aaa_pie_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .width = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = aaa_study_pie) +
  scale_fill_brewer() +
  ggtitle("1-cycle Cyclical Power Mode")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

####2-Cycles
```{r  AAA: fit 2-cycle single cycle model}
aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments=2)

fit12_aaa_pie <- stan(file = 'models/single_cycle_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

#model <- stan_model(file = 'models/single_cycle_model.stan') 

fit12_aaa_pie_data <- spread_draws(fit12_aaa_pie, b)

unique_correct_ans_aaa <- unique(aaa_study_pie$Value)

fit12_aaa_pie_data <- merge(fit12_aaa_pie_data, unique_correct_ans_aaa, all=TRUE)

segments <- c(2);
#update this with segments used in the model

fit12_aaa_pie_data <- fit12_aaa_pie_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit12_aaa_pie_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .width = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = aaa_study_pie) +
  scale_fill_brewer() +
  ggtitle("2-cycle Cyclical Power Mode")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```


####4-Cycles
```{r  AAA: fit 4-cycle single cycle model}
aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments=4)

fit14_aaa_pie <- stan(file = 'models/single_cycle_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

#model <- stan_model(file = 'models/single_cycle_model.stan') 

fit14_aaa_pie_data <- spread_draws(fit14_aaa_pie, b)

unique_correct_ans_aaa <- unique(aaa_study_pie$Value)

fit14_aaa_pie_data <- merge(fit14_aaa_pie_data, unique_correct_ans_aaa, all=TRUE)

segments <- c(4);
#update this with segments used in the model

fit14_aaa_pie_data <- fit14_aaa_pie_data%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[1])*(1/segments[1]),
    ri_value = riminus_value + 1/segments[1],
    p = (((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[1]) + (riminus_value))*100,
    )

fit14_aaa_pie_data %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (p-y)), .width = c(.99, .95, .8, .5)) +
  geom_point(aes(y = (flipped_ans - Value), x = Value ), data = aaa_study_pie) +
  scale_fill_brewer() +
  ggtitle("4-cycle Cyclical Power Mode")+
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

###Weighted Cycles Model
```{r  AAA: fit weighted cycles model}

aaa_pie_data = list(n = length(aaa_study_pie$ID), number_segments = 3, correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments = c(1,2,4))

fit2_aaa_pie <- stan(file = 'models/weighted_cycles_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

saveRDS(fit2_aaa_pie, "fit_aaa_weighted_cycles.rds")

#fit2_pie <- readRDS("fit_aaa_weighted_cycles.rds")

#building the new DB
b_and_p <- as.matrix(fit2_aaa_pie, pars = c("prob_segment", "b" ))
fit_data_m_aaa <- as.data.frame(b_and_p)

unique_correct_ans <- as.data.frame(unique(aaa_study_pie$Value))

fit_data_m_aaa <- cbind(fit_data_m_aaa, correct_ans = rep(unique_correct_ans$`unique(aaa_study_pie$Value)`, each = nrow(fit_data_m_aaa)))

    b = fit_data_m_aaa$b
    prob_segment1 = fit_data_m_aaa$`prob_segment[1]`
    prob_segment2 = fit_data_m_aaa$`prob_segment[2]`
    prob_segment3 = fit_data_m_aaa$`prob_segment[3]`
    segment1 = 1
    segment2 = 2
    segment3 = 4
    correct_ans = fit_data_m_aaa$correct_ans/100

    riminus_value1 = floor(correct_ans*segment1)*(1/segment1);
    ri_value1 = riminus_value1 + 1/segment1;
    p1 = ((correct_ans - riminus_value1)^b)/((correct_ans - riminus_value1)^b+(ri_value1 - correct_ans)^b)*(1/segment1) + (riminus_value1);

    riminus_value2 = floor(correct_ans*segment2)*(1/segment2);
    ri_value2 = riminus_value2 + 1/segment2;
    p2 = ((correct_ans - riminus_value2)^b)/((correct_ans - riminus_value2)^b+(ri_value2 - correct_ans)^b)*(1/segment2) + (riminus_value2);

    riminus_value3 = floor(correct_ans*segment3)*(1/segment3);
    ri_value3 = riminus_value3 + 1/segment3;
    p3 = ((correct_ans - riminus_value3)^b)/((correct_ans - riminus_value3)^b+(ri_value3 - correct_ans)^b)*(1/segment3) + (riminus_value3);
    
    fit_data_m_aaa$p = (prob_segment1*p1 + prob_segment2*p2 + prob_segment3*p3)*100;
    
  fit_data_m_aaa %>%
  ggplot(aes(x = correct_ans)) +
  stat_lineribbon(aes(y = (p-correct_ans)), .width = c(.99, .95, .8, .5)) +
 # geom_point(aes(y = (flipped_ans - correct_ans), x = correct_ans ), data = flipped_pie_angle) +
  stat_smooth(data=aaa_study_pie, aes(x =Value, y =(flipped_ans-Value) ) , color = "green", span = .3) +
  stat_summary(fun.data = "mean_se", geom="pointrange", data = aaa_study_pie, aes(x =Value, y =(flipped_ans-Value))) +
  scale_fill_brewer() +
  ggtitle("Pie Mixture Model (1-cycle,2-cycle,4-cycle)") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
    
    mean(fit_data_m_aaa$`prob_segment[1]`)
    mean(fit_data_m_aaa$`prob_segment[2]`)
    mean(fit_data_m_aaa$`prob_segment[3]`)
    
```

###Weighted Cycles Model for 1-99 values
```{r  AAA: fit weighted cycles model}

fit_data_aaa <- spread_draws(fit2_aaa_pie, b, prob_segment[segment])

all_numbers <- (seq(1, 99, 1))

fit_data_aaa_merge <- merge(fit_data_aaa, all_numbers, all=TRUE)
# y stands for the correct answer

temp <- merge(fit_data_aaa, all_numbers, all=TRUE)

segments <- c(1,2,4);
#update this with segments used in the model

final_data_aaa_w <- fit_data_aaa_merge%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, b, y) %>%
        summarise(final_p = sum(weighted_p)) 

final_data_aaa_w %>%
  ggplot(aes(x = y)) +
  stat_lineribbon(aes(y = (final_p-y)), .width = c(.99, .95, .8, .5)) +
 # geom_point(aes(y = (flipped_ans - correct_ans), x = correct_ans ), data = flipped_pie_angle) +
  stat_smooth(data=aaa_study_pie, aes(x =Value, y =(flipped_ans-Value) ) , color = "green", span = .3) +
  stat_summary(fun.data = "mean_se", geom="pointrange", data = aaa_study_pie, aes(x =Value, y =(flipped_ans-Value))) +
  scale_fill_brewer() +
  ggtitle("Pie Weighted Cycles Model (1-cycle,2-cycle,4-cycle)") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

theme_set(theme_minimal())
    
```


```{r AAA: weighted cycles model QQ plot}

fit_data_m_aaa%>%
  summarise(
    p_residual = mean(p < correct_ans),
    z_residual = qnorm(p_residual)
  ) %>%
  ggplot(aes(sample = z_residual)) +
  geom_qq() +
  geom_abline()
```

```{r AAA: weighted cycles model posterior plot}
predicted_data <- fit_data_m_aaa
observed_data <- aaa_study_pie

ggplot(predicted_data, aes(correct_ans, p)) + geom_point() + geom_point(data = observed_data, aes(Value, flipped_ans), colour='red') + ggtitle("Pooled Power, Pooled Weights Model") + labs(x = "Correct Answer", y="Response")
```


###Pooled Weights, Individual Power Model

#### Reconstructing Model
```{r AAA: fit PWIP model}
aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = aaa_study_pie$ID, k = max(aaa_study_pie$ID))

fit3_aaa_pie <- stan(file ='models/pooled_wts_indv_power.stan' , data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

saveRDS(fit3_aaa_pie, "fit_aaa_pooled_wts_indv_power.rds")

#fit3_pie <- readRDS("fit_aaa_pooled_wts_indv_power.rds")


fit_data_aaa_pie_p <- spread_draws(fit3_aaa_pie, b[participant_ID], prob_segment[segment])

unique_correct_ans <- unique(aaa_study_pie$Value)

fit_data_aaa_pie_p_f <- merge(fit_data_aaa_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_data_aaa_3 <- fit_data_aaa_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, b, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
colnames(aaa_study_pie)[1] <- "participant_ID"

final_data_aaa_3 %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(aaa_study_pie, participant_ID <= 9 )) +
  ggtitle("Pooled Weights Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

theme_set(theme_minimal())

```

#### Posterior Plot
```{r AAA: Posterior plots PWIP model}

aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = aaa_study_pie$ID, k = max(aaa_study_pie$ID))

PWIP_fit <- stan(file ='models/pooled_wts_indv_power.stan' , data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

PWIP_predicted_data <- spread_draws(PWIP_fit, response_pred[i]) %>%
  summarise_all(list)

PWIP_combined_data <- unnest(bind_cols(aaa_study_pie, PWIP_predicted_data))


PWIP_combined_data %>%
    ggplot(aes(x = Value/100)) +
      stat_lineribbon(aes(y = (response_pred - Value/100)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      geom_point(aes (y = (flipped_ans/100 - Value/100)), data = aaa_study_pie) +
  ggtitle("Posterior for Pooled Weights Individual Power Model") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

```

#### QQ Plot
```{r AAA: PWIP model QQ plot}

PWIP_combined_data%>%
  group_by(i) %>%
    summarise(
      p_residual = mean(response_pred < flipped_ans/100),
      z_residual = qnorm(p_residual)
    ) %>%
    ggplot(aes(sample = z_residual)) +
    geom_qq() +
    geom_abline()+ 
    ggtitle("QQ plot for Pooled Weights Individual Power Model")

```


###Individual Weights, Pooled Power Model

#### Reconstructing Model
```{r AAA: fit IWPP model}
fit4_aaa_pie <- stan(file = 'models/indv_wts_pooled_power_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE ,control = list(adapt_delta = 0.9))

saveRDS(fit4_aaa_pie, "fit_aaa_indv_wts_pooled_power.rds")

summary(fit4_aaa_pie)

#fit4_aaa_pie <- readRDS("fit_aaa_indv_wts_pooled_power.rds")

fit_data_aaa_pie_p <- spread_draws(fit4_aaa_pie, b, prob_segment[participant_ID][segment])

unique_correct_ans <- unique(aaa_study_pie$Value)

fit_data_aaa_pie_p_f <- merge(fit_data_aaa_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_aaa_data4 <- fit_data_aaa_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, b, participant_ID, y) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
#colnames(pie)[1] <- "participant_ID"

final_aaa_data4 %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (final_p - y)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3 ) + 
      geom_point(aes (y = (flipped_ans - Value), x=Value ), data= subset(aaa_study_pie, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weights Pooled Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

```


#### Posterior Plot
```{r AAA: posterior plots IWPP model}

aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = aaa_study_pie$ID, k = max(aaa_study_pie$ID))

IWPP_fit <- stan(file ='models/indv_wts_pooled_power_model.stan' , data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE, control = list(adapt_delta = 0.95, max_treedepth = 15))

IWPP_predicted_data <- spread_draws(IWPP_fit, response_pred[i]) %>%
  summarise_all(list)

IWPP_combined_data <- unnest(bind_cols(aaa_study_pie, IWPP_predicted_data))


IWPP_combined_data %>%
    ggplot(aes(x = Value/100)) +
      stat_lineribbon(aes(y = (response_pred - Value/100)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      geom_point(aes (y = (flipped_ans/100 - Value/100)), data = aaa_study_pie) +
  ggtitle("Posterior for Individual Weights Pooled Power Model") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

```

```{r}
sampler_params <- get_sampler_params(IWPP_fit, inc_warmup = TRUE)
summary(do.call(rbind, sampler_params), digits = 2)

pairs(IWPP_fit, pars = c("b", "phi", "lp__"), las = 1)

pairs(IWPP_fit, pars = c("sigma", "phi", "lp__"), las = 1)
```

```{r}
aaa_study_pie_subset = subset(aaa_study_pie, ID <= 10)

aaa_pie_data_subset = list(n = length(aaa_study_pie_subset$ID), correct_ans = aaa_study_pie_subset$Value/100, response = aaa_study_pie_subset$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = aaa_study_pie_subset$ID, k = max(aaa_study_pie_subset$ID))

IWPP_fit_subset <- stan(file ='models/indv_wts_pooled_power_model.stan' , data = aaa_pie_data_subset, iter = 1000, chains = 1, verbose=TRUE, control = list(adapt_delta = 0.95, max_treedepth = 15))

sampler_params <- get_sampler_params(IWPP_fit, inc_warmup = TRUE)
summary(do.call(rbind, sampler_params), digits = 2)

pairs(IWPP_fit, pars = c("b", "phi", "lp__"), las = 1)

pairs(IWPP_fit, pars = c("sigma", "phi", "lp__"), las = 1)
```


#### QQ Plot
```{r AAA: QQ plot IWPP model }

IWPP_combined_data%>%
  group_by(i) %>%
    summarise(
      p_residual = mean(response_pred < flipped_ans/100),
      z_residual = qnorm(p_residual)
    ) %>%
    ggplot(aes(sample = z_residual)) +
    geom_qq() +
    geom_abline()+ 
    ggtitle("QQ plot for Individual Weights Pooled Power Model") +
    theme_minimal()

```


###Individual Power, Individual Weights Model

#### Reconstructing Model
```{r AAA: fit IWIP model}

fit5_aaa_pie <- stan(file = 'models/indv_wts_and_power_model.stan', data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE,control = list(adapt_delta = 0.99))

saveRDS(fit5_aaa_pie, "fit_aaa_indv_wts_indv_power.rds")

saveRDS(fit5_aaa_pie, "fit_aaa_indv_wts_indv_power_expo.rds")

#fit5_aaa_pie <- readRDS("fit_aaa_indv_wts_indv_power.rds")

fit_data_aaa_pie_p <- spread_samples(fit5_aaa_pie, b[participant_ID], prob_segment[participant_ID][segment])

unique_correct_ans <- unique(aaa_study_pie$Value)

fit_data_aaa_pie_p_f <- merge(fit_data_aaa_pie_p, unique_correct_ans, all=TRUE)
# y stands for the correct answer

segments <- c(1,2,4);
#update this with segments used in the model

final_aaa_data5 <- fit_data_aaa_pie_p_f%>%
  mutate(
    correct_ans = y/100, 
    riminus_value = floor((correct_ans)*segments[segment])*(1/segments[segment]),
    ri_value = riminus_value + 1/segments[segment],
    p = ((correct_ans - riminus_value)^b)/((correct_ans - riminus_value)^b+(ri_value - correct_ans)^b)*(1/segments[segment]) + (riminus_value),
    weighted_p = p*prob_segment*100
    ) %>%
      group_by(.chain, .iteration, participant_ID, y, b) %>%
        summarise(final_p = sum(weighted_p)) 

## Changed column name!
#colnames(pie)[1] <- "participant_ID"

final_aaa_data5 %>%
  filter(participant_ID <= 9) %>%
    ggplot(aes(x = y)) +
      stat_lineribbon(aes(y = (y-final_p)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      facet_wrap( ~ participant_ID, nrow = 3) + 
      geom_point(aes (y = (Value - flipped_ans), x=Value ), data= subset(aaa_study_pie, participant_ID <= 9 )) +
  coord_cartesian(ylim = c(-10, 10)) +
  ggtitle("Individual Weight, Individual Power Model for Particpants 1-9") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()
```

#### Posterior Plot
```{r AAA: posterior plots IWIP model}

aaa_pie_data = list(n = length(aaa_study_pie$ID), correct_ans = aaa_study_pie$Value/100, response = aaa_study_pie$flipped_ans/100, segments = c(1,2,4), number_segments = 3, participant = aaa_study_pie$ID, k = max(aaa_study_pie$ID))

IWIP_fit <- stan(file ='models/indv_wts_and_power_model.stan' , data = aaa_pie_data, iter = 1000, chains = 1, verbose=TRUE)

IWIP_predicted_data <- spread_draws(IWIP_fit, response_pred[i]) %>%
  summarise_all(list)

IWIP_combined_data <- unnest(bind_cols(aaa_study_pie, IWIP_predicted_data))


IWIP_combined_data %>%
    ggplot(aes(x = Value/100)) +
      stat_lineribbon(aes(y = (response_pred - Value/100)), .width = c(.99, .95, .8, .5)) +
      scale_fill_brewer() +
      geom_point(aes (y = (flipped_ans/100 - Value/100)), data = aaa_study_pie) +
  ggtitle("Posterior for Individual Weights Individual Power Model") +
  labs(x = "True Proportion", y="Bias") +
  theme_minimal()

```

#### QQ Plot
```{r AAA: QQ plot IWIP model }

IWIP_combined_data%>%
  group_by(i) %>%
    summarise(
      p_residual = mean(response_pred < flipped_ans/100),
      z_residual = qnorm(p_residual)
    ) %>%
    ggplot(aes(sample = z_residual)) +
    geom_qq() +
    geom_abline()+ 
    ggtitle("QQ plot for Indvidual Weights, Individual Power Model")+
    theme_minimal()

```
